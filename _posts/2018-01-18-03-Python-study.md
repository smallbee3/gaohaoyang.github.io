# 04 Python

---

#### __TABLE__


>#####_01. Note_
>
>#####_02. Storehouse_
>#####_03. Site_
>#####_04. Bookmark_
>#####_05. Question_

---




<br>
01 Notetaking
-------------

> 콜론과 들여쓰기 : 이 다음에는 블록이 필요하다.


동적타이핑?

2에서 3로 옮기기 위해서 
파이썬의 강력한점 관련된 서드파티 라이브러리가 많다는 것.
다 호환성이 없어진 거예요.

언어가 망할 수도 있었는데 모든 파이썬 언어들이 3로 옮기는 엄청난 과정.
진통.

현업에서 쓸 수 있게 된지는 2년도 안됬어요.
7년동안을 호환 맞추는데 씀.

2~3년 전만해도 2에서 하는법 같이 배움.

2~3달 전에 장고 2.0이 나왔는데 파이썬 2.0을 걷어냄.

대부분의 사람들이 코드를 거의 비슷해짐.

전혀 그렇지 않아 도퇴된 언어가 펄과 루비가 있음.
장고가 루비를 쓴 웹 ㅍ레임워크가 레비.
짜는 사람에 다라서 극악으로 효율이 달라짐.

장고는 파이선의 철학을 따라가서 다른 개발자와 

파이썬을 쓰는 자유로운 프레임워크가
플라스크가 있는데 

플라스크와 장고싸움에서 장고가 이김.


파이썬의 핵심자체가 하나의 문제를 해결하는데 하나의 방법만 스자.

펄은 한가지 문제 해결하는데 한가지만 못쓴다.

데이터분석이나 데이터사이언스에서 numpy나 pygame을 씀.

파이썬 쓰는사람이 이걸 해야겠다고 만든 써드파티 라이브러리.
--

OS는 보수적으로. 예전에 쓰는 버전이 잇기 대문에...

3가 아니라 버전이 엄청 많음.

3에서도 3.6 버전까지 나옴.

3.3.1까지는 문제없음.

3.3에서 3.4가지 가는데 많은 기능이 추가. 
내가 만약 3.4에서 개발을 햇을 대 나중에 3.2에서만 돌아가ㅡㄴ 프로젝트가 잇으면동시에 깔면 굉장히 복잡해짐.
파이썬 버전에 따라서 관리를 하고 싶은 거예요..

내 컴퓨터에는 3.4밖에 없다. 그렇다고 다시 깔 수는 없죠. 그래서 파이 버전을 관리해주는 것.

파이썬마다 써드파티 라이브러리가 많은데 5년 전에 만든거는 5년 전 버전.

옛날 것과 충돌이 날 수도 있음.

충돌을 방지하는 방법까지 제공.

파이썬 버전이랑 개발환경을 관리해요.

해석할 파이썬의 버전이랑 어떤 프로그램이 있는지.

설치하고 삭제하는게 프로젝트마다 따로 공간이 할당되요.
그게 버츄어 env 

pyenv와 virtualenv 따로 쓰기 귀찮아서
합쳐서 만듦.




> 값을 주고도 변하지 않음. 
> 바뀐다면 다른 방식..
>
>값이 아니라 의미를 표현하거나 값을 반환하는 방식.
>
>
>
>객체 가 아닌 것도 잇음.
>객체를 사용하기 위해서는 변수 선언
>
>변수는 단지 이름일 뿐.
>어더한 값을 갖는 것이 아니다.
>
> 특정 객체를 참조하는 것.
> 
> id() 어떤 고유값을 가지고 있는지 출력.
> 
> 고유값이 겹친다는 것은 
> 
> 참조하는 모든 것은 객체이고 주소를 가짐.

> 
> 
> print(id(50))
> print(id(50))
> print(id(284829u5892598280592308402)
> print(id(284829u5892598280592308402)> 
> 
> 컴퓨터에 메모리가 있는데
> 그 중에 파이썬이 공간을 쓰는 것.
> 각각이 주소를 가짐
> 
> 객체는 항상 메모리에 할당이 됨.
> var1, var2, var3, var4가 같은 값을 참조함.
> 4520349440이라는 값을 가지는 것. 
> 100을 갖는게 아니라.
> 
> 굉장히 큰수를 출력하면 달라짐
> print(id(98293480820384))
> 한번 출력하면 참조하고 다음줄로 넘어가면 참조하는 것이 없어짐.
> c나 c++은 내가 없애좀
> 객체를 참조하는 것이 없어졌어요 레퍼런스 카운터가 0이 되면 날라짐.
> 왜 50은 항상 같냐?
> 1부터 100인가 천인가 부터는 굳이 넣었다 뺄다 할 필요가 없기대무ㅐㄴ에 무조건 변수를 할당을 해요 객체를.
> 개내를 참조하면 항상 같은 메모리 주소가 나와요.
> 
> var1 = 101
> print(id(var1))
> print(id(var2))
> 
> 
> var1이 가르키는 것을 바꾸면
> var2,3,4는 var1을 가르키는 것이 아니라 다른 값을 가리킴.
> 
> 
> 내장함수 type사용
> 
> 문자열형 객체다.
> 
> 사용가능한 문자 제한
> 소문자/대문자/숫자/언더스코어
> 
> 일단 숫자로는 시작할 수 없음.
> 언더스코어로 사용하는 것은 특별히 따로 사용하는 법이 있음.
> 변수는 소문자로 시작하고 대문자로 시작하지 않음.
> 
> 구문을 표현할 때 쓰는 건 변수로 쓸 수 없음.
> 
> type는 참조하고 있는 객체의 자료형?
> 
> 
> 문자열 안에 문자열을 선언할 때 
> 바깥쪽을 작은 /다옴표로 쓰는게 이득.
> 왜냐면 안에 큰따옴표를 쓸 수 있음.
> 
> -> 평소 ' 쓰는 습관을 들이자.
> 
> 
> 형변환 str이라는 내장함수 사용.
> 
문자열을 제외한 print함수로 호출하면 해당 객체에 str함수를 사용한 결과를 나타내준다.
> 
> \n
> \
> \\ \(역슬래시) 입력
> 
> 인덱스 연산
> 
> 문자열 객체는 불변.
> 
> 인덱싱 한다음에 새 값을 넣을 수 없음.
> 
> 인덱스 대입이 안됨.
> lux = '빛으로 강타해요!'
> lux[0] = '손' 이 안됨
> 
> 파이썬에서 괄호로 감싸진 부분에는 엔터를 쳐도 상관없음.
> 
> ㅌ그정 타임만 오게 호면 타입 지정자.
> 
> 문자를 반복하는 가장 쉬운방법은 * 연산을 하는 것.
> 
--
> 문자열과는 다르게 안에 요소를 변경할 수 있음.
> 
> 리스트의 생성
> sample_list = list('League of legends')

list() 로하면 그냥 list만 됨.
모든 자료타입은 class로 이루어짐.
class는 형태인데.
모든 요소가 객체선언되어있음.
insert는 인덱스를 따지지 않고 맨 처음 들어감.


break확인 (else)
for문으로 데이터를 순회하던 중, break문이 호출되지 않고 반복문이 종료되면 else문이 실행된다.


### pass
아무것도 하지 않는 문법

### break
else 문도 탈출한다.
말이 어렵게 되있음.
"break확인 (else)
for문으로 데이터를 순회하던 중, break문이 호출되지 않고 반복문이 종료되면 else문이 실행된다."


### for else + break
for 반복문이 종료된 시점에서 이 종료가 모든 반복을 다 수행한 후의 정상적인 종료인지, 아니면 break 명령에 의한 강제 종료인지에 따라서 수행해야 될 일을 구분할 필요가 있는 경우에 for~else 구문을 사용하면 된다.

### range()
range()함수는 특정 범위의 숫자 스트림 데이터(객체)를 반환한다.
난 리스트를 반환하는지 알았다...

따라서 range() 함수는 for in 이나 list() 등으로 형변환해서 사용해야 한다.



#### 왜 리스트는 일반 변수의 할당과는 다르게 한 변수의 값이 바뀌면 다른 변수의 값도 바뀌는지
var1 = 'Lux'
var2 = var1

var1 = 'Ahri'
print(var2) -> Lux

vs


list1 = [ 'a', 'b', 'c']
list2 = list1

list1.insert(100, 'z)
print(list1) -> [ 'a', 'b', 'c', 'z']
print(list2) -> [ 'a', 'b', 'c', 'z']

print(id(list1))
print(id(list2)) 
위 두 값이 같음


리스트 객체에 대해서 이해해야함.

리스트 오브젝트는 내부에 객체를 가짐.
대괄호 리스트 자체에 연결.
리스트 안에 있는 요소들은 각자 또 다른 곳에 있는 객체들을 가리킴.
리스트 1에 어디를 삽입하면 그 것도 다른 값을 가르킴.
리스트 자체는 그대로 있음.


즉 리스트 객체는 리스트가 어던 값을 가리키고 그 안의 요소가 또 가리킴..

그런데 cp를 쓰면 리스트 자체가 가리키는 값이 바뀌기 때문에 위와 같은 연산을 했을 때 다른 결과



del이라는 내장함수의 offset을 입력

del fruits[0]

remove는 값으로 삭제



### zip은 인덱스 오류 없이 있는데까지만 출력




range(1900000000000)
함수는 효율적으로 .


장고는 10번 이상의 무한루프 발생하면 멈춤


시퀀스는 이터러블한 객체.

이터러블 안에 시퀀스가 포함.

for in [ 이터러블한 객체]

파이선에서는 문자열이 뒤에 올 때
하나씩 출력을 함



<br><br>
02 Storehouse
-------------

### // : 나눗셈의 몫(정수)을 구할 때
### /  : 나눗셈의 몫을 실수로 구할 때

### int() : 정수(integer)로 바꾸기
### float() : 부동소수점(floating point)으로 바꾸기


### list(list) : 다른 변수를 담을 수 있는 변수


### 리스트 삭제 세가지
list.remove(40)
&
del list[40]
&
del(list[40])

### 두 딕셔너리를 더할 때 키 값이 값을 경우
키가 같아 충돌하는 부분은 update() 함수에 실행인자로 넘긴 딕셔너리의 값으로 업데이트 됨


### 한 딕셔너리 안에 같은 키의 값이 2개 이상 있을 때 
호출하면 랜덤으로 나온다.


### except Exception

except as ex:
	print('오류가 발생했습니다.', ex)
ex에 예외 종류를 저장함.

모든 예외의 상위 예외이므로 Exception을 잡으면 어떤 예외라도 잡을 수 있음. 모든 예외를 잡아야 하는 상황이 아니라면 쓰지 않는 것이 좋음.
하지만 상위 예외 이름을 써 하위 예외를 잡으면 의도하지 않은 예외까지 함께 잡기 때문에 디버깅 하기가 어려질 수 있음. p.250(hello)




함수정리
--------

### type()
함수의 자료형을 반환


### 현재시각 저장 함수
import datetime
now = datetime.datetime.now()
now.year == 연
now.month == 달
now.day == 일


### .format()
형식에 맞춰 값을 문자열로 만들어 주는 기능을 합니다.  

### round()
반올림 값을 계산하는 함수
* math에 들어있지 않음.

### ceil (올림)
### floor (내림)


### range(n)
0에서부터 n개 만큼 차례대로 나열되는 숫자

### range(a, b)
a부터 b개의 숫자를 차례대로 나열되는 숫자


### for in range
횟수가 정해져 있거나 1씩 증가하는 숫자를 써야 할 때.


### len()
argument로 전달받은 변수에 항목이 몇 개 들어 있는지 개수를 되돌려 주는 함수

### math.pi
import math를 상단에 적어준다.


### for in list
이미 내가 사용할 값의 목록이 정해져 있고, 그 목록에서 값을 하나씩 꺼내 쓰기만 하면 될 때.

### random.choic(candidates)
candidates라는 리스트에서 하나를 무작위로 고르는 함수.

### Get Web


### (딕셔너리의) .items()
딕셔너리의 key와 value를 동시에 넘겨주는 함수.
딕셔너리 안에 있는 함수?
for key, value in ages.items():
	print('{}의 나이는 {}입니다.(key, value))


### (딕셔너리&리스트) clear()
안의 내용을 지우는 함수

### (딕셔너리) .update()
두 딕셔너리를 더할 때 사용
 
### (셋) .update()
두 셋을 합칠 때 사용 
 
 
### 슬라이스

처음은 이상

마지막은 미만


  
### 문자열 나누기(split)
문자열의 내장함수 split을 사용
split함수에 인자로 주어진 구분자를 기준으로 하나의 문자
열을 리스트 형태로 반환해준다.

*스플릿에서 아무것도 안넣으면 공백을 기준으로 나눔*
 공백 넣어도 결과같은 똑같음.
 


### 문자열 결합(join)


### sort() 
리스트 자체를 정렬

### sorted()
리스트의 정렬 복사본을 반환

### copy()
리스트 복사


### insert(a, b)
인덱스 a번 자리에 b를 넣는 것
b 원래있던 요소와 그 뒤 요소들은 뒤로 한 칸씩 밀림.

인덱스를 벗어나는 값을 넣어도 괜찮음. 
대신 가장 마지막에 해당 값이 들어감.


### isinstance(인스턴스, 자료형)
자료형을 검사하는 함수



개념정리
--------


### 매개변수(parameter)  


### 실행인자(argument)
positional arguments: 순서대로 넣어야하는 실행인자  


### 부동소수점 : python에서 사용하는 실수표현방법
정수는 정수 영역만 다룰 수 있는 대신 항상 정확하다는 보장이 있고, 부동소수점은 실수 영역까지 다룰 수 있는 대신 정확성은 보장하지 않습니다.


### 모듈
미리 만들어진 코드를 import <모듈 이름>으로 가져오는 것, 주로 함수이나 math.pi처럼 변수로도 이루어질 수 있다.
<모듈 이름>.<모듈 안의 구성 요소>


### 튜플
0) 튜플을 사용할 때
- 두 변수의 값을 맞바꿀 때
- 여러 개의 값을 한 번에 전달할 때
- 딕셔너리의 키에 값을 여러개 넣을 때

1) 튜플은 소괄호를 생략해도 튜플이다.
2) 요소가 하나밖에 없을 때는 요소 뒤에 comma(,)를 넣어줘야 한다.
ex) a = 1,
    b = ('red') -> 문자열
    c = ('red',) -> 튜플
    c = 'red', -> 튜플
3) 튜플은 리스트를 사용해서 만들 수 있다. (튜플이 튜플을 사용은 x)
ex) list = [1, 2, 3]
    tuple2 = tuple(list)
4) *딕셔너리의 키로 리스트나 딕셔너리는 사용할 수 없지만 튜플은 사용가능하다.
because 그 값이 항상 고정되어 있기 때문.*

5) 함수에서 여러 개의 값을 한 번에 반환할 때



6) 튜플 함수를 통해 (리스트를) 형 변환을 시킬 수 있음

7) 반대로 join으로 리스트를 문자열로 형변환 시킬 수 있다.
''.join(튜플)
''.join(리스트)



### 패킹
튜플을 이용해서 변수 하나에 값을 여러 개의 값을 넣는 것

### 언패킹
패킹된 변수에서 여러 개의 값을 꺼내오는 것



### 딕셔너리

1 형변환도 가능
2 딕셔너리는 순서가 없어서 시퀀스 객체가 아님.
3 update() 로 결합하는데 같은 키 값은 나중 값으로 덮어진다.
4 del champion_dict['Lux']
5 전체삭제는 clear


### 셋

1 리스트에서 중복을 삭제할 때 가장 쉬운 방법
2 ex) list(abaakdsjljsdfjldsf)

set(list)
딕셔너리는 키만 남습니다.
3 집합 연산이 됨.
4 







Error types
--------------

### indexError(색인오류) 
리스트에 존재하지 않는 항목에 접근하려할 때.
list index out of range.

### Syntax error
문법오류

### NameError
이름오류는 명령어, 함수이름, 변수이름 등을 잘못 입력했을 대 발생하는 오류












<br><br>
03 Sites
------------










<br><br>
04 Bookmark
-------------

Try! helloworld 파이썬


p.44 'ab' == 'a' + 'b'
p.48 'aaaa' == 'a' * 4





<br><br>
05 Question
-------------


1. import 하지 않고도 쓸 수 있는 이유
2. .items 의 .은 함수이름에 포함?
    .format처럼?
3. REPL에서 리스트나 딕셔너리치면 그냥 출력되는 이유.?



1. list = 3
   이렇게 한번 선언되면 그 이후에는 list 함수가 위의 선언에 의해
   덮어씌워져서 부를 수 없게 된다. 'not calllable'
	-> 그때는 delete list 로 기존에 할당된 값을 삭제해야한다.

2. for in 뒤에 리스트, 딕셔너리, 튜플, 문자 모두 올 수 있으며
   문자열의 경우 한 글자씩 연산이 된다.
   왜냐면 iterable한 요소기 때문에 
   





1) jupyter 한번 연산이 계속 중첩되는데 어떻게 삭제하는지

2) 주석처리한 것도 이상하게 뜨고
   결과값이 없이 인터프리터 연산인데도 막 뜸.
   
3) 또다른 champion변수가 존재하기 때문에 할당하기 전인 변수를 사용한 것으로 판단

                                 

셋 쓰면 연산이 많이 들ㅇ가니까 비효율적임.






---


점프투파이썬 보면 됨.



x, y 

튜플이 가르키는 객체가 바뀌는 거지 튜플 자체가 바뀌는 것은 아님.



값이 바뀌는 것은 불가능 하지만, 주소를 바꿔주는 것.




